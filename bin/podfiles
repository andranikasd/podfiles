#!/usr/bin/env bash
# podfiles — Tools on demand, inside your pods/containers.
# Fuckless Debugging in containerized environments.
set -Eeuo pipefail

readonly VERSION="0.1.1"
readonly SELF="$(basename "$0")"

# Defaults (override via env)
: "${PODFILES_EPHEMERAL_IMAGE:=nicolaka/netshoot:latest}"
: "${PODFILES_BUSYBOX_URL_AMD64:=https://busybox.net/downloads/binaries/1.36.1-x86_64-linux-musl/busybox}"
: "${PODFILES_BUSYBOX_URL_ARM64:=https://busybox.net/downloads/binaries/1.36.1-aarch64-linux-musl/busybox}"
: "${PODFILES_TMP_DIR:=/tmp/podfiles}"
: "${PODFILES_BIN_DIR:=/tmp/podfiles/bin}"

# Colors
enable_colors() {
  # color if stdout or stderr is a TTY and NO_COLOR not set
  if { [ -t 1 ] || [ -t 2 ]; } && [ -z "${NO_COLOR:-}" ]; then
    if command -v tput >/dev/null 2>&1 && tput setaf 1 >/dev/null 2>&1; then
      C_BOLD="$(tput bold)"; C_DIM="$(tput dim)"; C_RED="$(tput setaf 1)"
      C_GRN="$(tput setaf 2)"; C_YLW="$(tput setaf 3)"; C_CYN="$(tput setaf 6)"
      C_RST="$(tput sgr0)"
    else
      C_BOLD=$'\033[1m'; C_DIM=$'\033[2m'; C_RED=$'\033[31m'
      C_GRN=$'\033[32m'; C_YLW=$'\033[33m'; C_CYN=$'\033[36m'
      C_RST=$'\033[0m'
    fi
  else
    C_BOLD=''; C_DIM=''; C_RED=''; C_GRN=''; C_YLW=''; C_CYN=''; C_RST=''
  fi
}
enable_colors

need() { command -v "$1" >/dev/null 2>&1 || { printf '%b[podfiles]%b Missing: %s\n' "$C_RED" "$C_RST" "$1" >&2; exit 127; }; }
say()  { printf '%b[podfiles]%b %s\n' "$C_CYN" "$C_RST" "$*" >&2; }
die()  { printf '%b[podfiles:ERR]%b %s\n' "$C_RED" "$C_RST" "$*" >&2; exit 1; }

usage() {
  cat <<EOF
${C_BOLD}$SELF v$VERSION${C_RST} — Tools on demand, inside your pods.

${C_BOLD}USAGE${C_RST}
  $SELF k8s shell [-n NAMESPACE] POD
  $SELF k8s attach [-n NAMESPACE] POD [--image IMG] [--name NAME] [--] [CMD...]
  $SELF k8s copy-busybox [-n NAMESPACE] POD [--as ping,nslookup,wget,sh]
  $SELF docker netshoot CONTAINER [--] [CMD...]
  $SELF docker copy-busybox CONTAINER [--as ping,nslookup,wget,sh]
  $SELF version | -h | --help

${C_BOLD}NOTES${C_RST}
  • attach uses 'kubectl debug' (ephemeral container sharing target namespaces).
  • copy-busybox uploads static BusyBox and symlinks requested applets into ${PODFILES_BIN_DIR}.
  • docker netshoot runs the toolbox sharing target container's network namespace.

${C_DIM}Fuckless Debugging in containerized environments.${C_RST}
EOF
}

case "${1:-}" in
  ""|-h|--help) usage; exit 0;;
  version) echo "$VERSION"; exit 0;;
esac

detect_arch() {
  case "$(uname -m)" in
    x86_64|amd64) printf 'amd64\n' ;;
    aarch64|arm64) printf 'arm64\n' ;;
    *) printf 'amd64\n' ;;
  esac
}

# ---- K8s helpers ----
k8s_attach() {
  need kubectl
  local ns="" pod="" img="$PODFILES_EPHEMERAL_IMAGE" name=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -n|--namespace) ns="$2"; shift 2;;
      --image) img="$2"; shift 2;;
      --name) name="$2"; shift 2;;
      --) shift; break;;
      *) if [ -z "${pod:-}" ]; then pod="$1"; shift; else break; fi;;
    esac
  done
  # Remaining args are the command
  local cmd=( "${@:-/bin/bash}" )
  [ -n "$pod" ] || die "POD required"
  [ -n "$name" ] || name="podfiles-$(date +%H%M%S)-$RANDOM"

  # pick first container name if present
  local target=""
  target="$(kubectl get pod "$pod" ${ns:+-n "$ns"} -o jsonpath='{.spec.containers[0].name}' 2>/dev/null || true)"

  # Build command
  # shellcheck disable=SC2206
  local base=( kubectl debug "pod/$pod" --image="$img" -it --share-processes )
  [ -n "$ns" ] && base+=( -n "$ns" )
  [ -n "$target" ] && base+=( --target="$target" )
  base+=( --container="$name" -- )

  say "Ephemeral attach → ${C_DIM}${img}${C_RST}"
  exec "${base[@]}" "${cmd[@]}"
}

k8s_copy_busybox() {
  need kubectl; need curl
  local ns="" pod="" as_list="ping,nslookup,wget,traceroute,sh"
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -n|--namespace) ns="$2"; shift 2;;
      --as) as_list="$2"; shift 2;;
      *) if [ -z "${pod:-}" ]; then pod="$1"; shift; else break; fi;;
    esac
  done
  [ -n "$pod" ] || die "POD required"

  local url
  case "$(detect_arch)" in
    arm64) url="$PODFILES_BUSYBOX_URL_ARM64" ;;
    *)     url="$PODFILES_BUSYBOX_URL_AMD64" ;;
  esac

  say "Fetching BusyBox (${C_DIM}${url}${C_RST})"
  local tmp; tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
  curl -fsSL "$url" -o "$tmp/busybox"
  chmod +x "$tmp/busybox"

  kubectl exec ${ns:+-n "$ns"} "$pod" -- sh -lc "mkdir -p '$PODFILES_BIN_DIR' '$PODFILES_TMP_DIR'"
  kubectl cp "$tmp/busybox" "${ns:+$ns/}$pod:$PODFILES_BIN_DIR/busybox"

  IFS=',' read -r -a tools <<<"$as_list"
  local link_cmd=""
  for t in "${tools[@]}"; do
    t="$(printf '%s' "$t" | xargs)"
    [ -z "$t" ] && continue
    link_cmd="${link_cmd}ln -sf '$PODFILES_BIN_DIR/busybox' '$PODFILES_BIN_DIR/$t' ; "
  done
  link_cmd="${link_cmd}printf 'export PATH=%s:\\\$PATH\\n' '$PODFILES_BIN_DIR' > '$PODFILES_TMP_DIR/profile'"

  kubectl exec ${ns:+-n "$ns"} "$pod" -- sh -lc "$link_cmd"

  printf '%b%s%b\n' "$C_GRN" "✅ BusyBox installed into $pod:$PODFILES_BIN_DIR" "$C_RST"
  cat <<'MSG'
Use now:
  kubectl exec -it -n <ns> <pod> -- sh -lc 'export PATH=/tmp/podfiles/bin:$PATH; sh'
MSG
}

k8s_shell() {
  local ns="" pod=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -n|--namespace) ns="$2"; shift 2;;
      *) if [ -z "${pod:-}" ]; then pod="$1"; shift; else break; fi;;
    esac
  done
  [ -n "$pod" ] || die "POD required"
  # Try ephemeral first; fallback to busybox copy
  if k8s_attach ${ns:+-n "$ns"} "$pod" -- /bin/bash; then
    exit 0
  fi
  say "Ephemeral attach failed → falling back to BusyBox copy"
  k8s_copy_busybox ${ns:+-n "$ns"} "$pod" --as "ping,nslookup,wget,traceroute,sh"
  exec kubectl exec -it ${ns:+-n "$ns"} "$pod" -- sh -lc "export PATH=$PODFILES_BIN_DIR:\$PATH; sh"
}

# ---- Docker helpers ----
docker_netshoot() {
  need docker
  local target="${1:-}"; shift || true
  [ -n "$target" ] || die "CONTAINER required"
  local cmd=( "${@:-bash}" )
  say "netshoot → ${C_DIM}$PODFILES_EPHEMERAL_IMAGE${C_RST} sharing container:${target}"
  exec docker run --rm -it --network "container:${target}" "$PODFILES_EPHEMERAL_IMAGE" "${cmd[@]}"
}

docker_copy_busybox() {
  need docker; need curl
  local target="${1:-}"; shift || true
  [ -n "$target" ] || die "CONTAINER required"
  local as_list="ping,nslookup,wget,traceroute,sh"
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --as) as_list="$2"; shift 2;;
      *) break;;
    esac
  done

  local url
  case "$(detect_arch)" in
    arm64) url="$PODFILES_BUSYBOX_URL_ARM64" ;;
    *)     url="$PODFILES_BUSYBOX_URL_AMD64" ;;
  esac

  local tmp; tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
  curl -fsSL "$url" -o "$tmp/busybox"; chmod +x "$tmp/busybox"

  docker exec "$target" sh -lc "mkdir -p '$PODFILES_BIN_DIR' '$PODFILES_TMP_DIR'"
  docker cp "$tmp/busybox" "$target:$PODFILES_BIN_DIR/busybox"

  IFS=',' read -r -a tools <<<"$as_list"
  local link_cmd=""
  for t in "${tools[@]}"; do
    t="$(printf '%s' "$t" | xargs)"
    [ -z "$t" ] && continue
    link_cmd="${link_cmd}ln -sf '$PODFILES_BIN_DIR/busybox' '$PODFILES_BIN_DIR/$t' ; "
  done
  link_cmd="${link_cmd}printf 'export PATH=%s:\\\$PATH\\n' '$PODFILES_BIN_DIR' > '$PODFILES_TMP_DIR/profile'"

  docker exec "$target" sh -lc "$link_cmd"
  printf '%b%s%b\n' "$C_GRN" "✅ BusyBox installed into container:$target at $PODFILES_BIN_DIR" "$C_RST"
  cat <<'MSG'
Use now:
  docker exec -it <container> sh -lc 'export PATH=/tmp/podfiles/bin:$PATH; sh'
MSG
}

main() {
  case "${1:-}" in
    ""|-h|--help) usage; return 0;;
    version) echo "$VERSION"; return 0;;
  esac

  local sub="${1:-}"; shift || true
  case "$sub" in
    k8s)
      local action="${1:-}"; shift || true
      case "$action" in
        attach)        k8s_attach "$@";;
        copy-busybox)  k8s_copy_busybox "$@";;
        shell)         k8s_shell "$@";;
        *) usage; return 2;;
      esac
      ;;
    docker)
      local action="${1:-}"; shift || true
      case "$action" in
        netshoot)      docker_netshoot "$@";;
        copy-busybox)  docker_copy_busybox "$@";;
        *) usage; return 2;;
      esac
      ;;
    *) usage; return 2;;
  esac
}

# ---- Dispatcher ----
# If we're being sourced for tests (PODFILES_SOURCE_ONLY=1), skip dispatch.
if [ "${PODFILES_SOURCE_ONLY:-0}" = "1" ]; then
  return 0 2>/dev/null || exit 0
fi

sub="${1:-}"; shift || true
case "$sub" in
  k8s)
    action="${1:-}"; shift || true
    case "$action" in
      attach)        k8s_attach "$@";;
      copy-busybox)  k8s_copy_busybox "$@";;
      shell)         k8s_shell "$@";;
      *) usage; exit 2;;
    esac
    ;;
  docker)
    action="${1:-}"; shift || true
    case "$action" in
      netshoot)      docker_netshoot "$@";;
      copy-busybox)  docker_copy_busybox "$@";;
      *) usage; exit 2;;
    esac
    ;;
  *) usage; exit 2;;
esac

main "$@"