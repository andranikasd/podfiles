#!/usr/bin/env bash
# podfiles — Tools on demand, inside your pods/containers.
# Tagline: Fuckless Debugging in containerized environments.
set -Eeuo pipefail

###############################################################################
# Version & Self
###############################################################################
readonly VERSION="0.2.1"
# shellcheck disable=SC2292
readonly SELF="${0##*/}"

###############################################################################
# Defaults (override via env)
###############################################################################
: "${PODFILES_EPHEMERAL_IMAGE:=nicolaka/netshoot:latest}"
# Multiple candidate URLs; we try them in order (fast → fallback).
: "${PODFILES_BUSYBOX_URLS_AMD64:=\
https://frippery.org/files/busybox/busybox-x86_64 \
https://busybox.net/downloads/binaries/1.36.1-x86_64-linux-musl/busybox \
https://busybox.net/downloads/binaries/1.36.1-x86_64-linux-glibc/busybox}"
: "${PODFILES_BUSYBOX_URLS_ARM64:=\
https://busybox.net/downloads/binaries/1.36.1-aarch64-linux-musl/busybox}"

: "${PODFILES_TMP_DIR:=/tmp/podfiles}"
: "${PODFILES_BIN_DIR:=/tmp/podfiles/bin}"

###############################################################################
# UI (colors/icons) — respects NO_COLOR and non-TTY
###############################################################################
enable_colors() {
  if { [ -t 1 ] || [ -t 2 ]; } && [ -z "${NO_COLOR:-}" ]; then
    if command -v tput >/dev/null 2>&1 && tput setaf 1 >/dev/null 2>&1; then
      C_BOLD="$(tput bold)"; C_DIM="$(tput dim)"; C_RED="$(tput setaf 1)"
      C_GRN="$(tput setaf 2)"; C_YLW="$(tput setaf 3)"; C_CYN="$(tput setaf 6)"
      C_RST="$(tput sgr0)"
    else
      C_BOLD=$'\033[1m'; C_DIM=$'\033[2m'; C_RED=$'\033[31m'
      C_GRN=$'\033[32m'; C_YLW=$'\033[33m'; C_CYN=$'\033[36m'
      C_RST=$'\033[0m'
    fi
  else
    C_BOLD=''; C_DIM=''; C_RED=''; C_GRN=''; C_YLW=''; C_CYN=''; C_RST=''
  fi
  ICON_OK="✅"; ICON_FAIL="❌"; ICON_WARN="⚠️"; ICON_INFO="ℹ️"; ICON_RUN="▶️"
}
enable_colors

say()  { printf '%b%s%b %s\n' "$C_CYN" "[podfiles]" "$C_RST" "$*" >&2; }
ok()   { printf '%b%s%b %s\n' "$C_GRN" "[ok]" "$C_RST" "$*" >&2; }
warn() { printf '%b%s%b %s\n' "$C_YLW" "[warn]" "$C_RST" "$*" >&2; }
err()  { printf '%b%s%b %s\n' "$C_RED" "[err]" "$C_RST" "$*" >&2; }
need() { command -v "$1" >/dev/null 2>&1 || { err "Missing: $1"; exit 127; }; }

box() {
  local t="${1:-}"
  printf '%s\n' "┌──────────────────────────────────────────────────────────┐"
  printf '│ %s%-56s%s │\n' "$C_BOLD" "$t" "$C_RST"
  printf '%s\n' "└──────────────────────────────────────────────────────────┘"
}

###############################################################################
# Usage
###############################################################################
usage() {
  box "$SELF v$VERSION — Tools on demand, inside your pods"
  cat <<EOF
${C_BOLD}USAGE${C_RST}
  $SELF k8s shell [-n NAMESPACE] POD
  $SELF k8s attach [-n NAMESPACE] POD [--image IMG] [--name NAME] [--] [CMD...]
  $SELF k8s copy-busybox [-n NAMESPACE] POD [--as ping,nslookup,wget,sh]
  $SELF docker netshoot CONTAINER [--] [CMD...]
  $SELF docker copy-busybox CONTAINER [--as ping,nslookup,wget,sh]
  $SELF doctor
  $SELF version | -h | --help

${C_BOLD}WHAT IT DOES${C_RST}
  • ${C_BOLD}attach${C_RST} uses ${C_DIM}kubectl debug${C_RST} (ephemeral container) sharing the pod's namespaces.
  • ${C_BOLD}copy-busybox${C_RST} uploads a static BusyBox and symlinks applets into ${C_DIM}${PODFILES_BIN_DIR}${C_RST}.
  • ${C_BOLD}docker netshoot${C_RST} runs a toolbox sharing target container's network namespace.

${C_BOLD}NOTES${C_RST}
  • Needs ${C_BOLD}kubectl${C_RST} for k8s; ${C_BOLD}docker${C_RST} for Docker; ${C_BOLD}curl${C_RST} for BusyBox copy.
  • Ephemeral containers may require RBAC: verb=update resource=pods/ephemeralcontainers.

${C_DIM}Fuckless Debugging in containerized environments.${C_RST}
EOF
}

###############################################################################
# Helpers
###############################################################################
detect_arch_host() {
  case "$(uname -m)" in
    x86_64|amd64) printf 'amd64\n' ;;
    aarch64|arm64) printf 'arm64\n' ;;
    *) printf 'amd64\n' ;;
  esac
}

k_can_ephemeral() {
  command -v kubectl >/dev/null 2>&1 || return 1
  if kubectl auth can-i update pods/ephemeralcontainers >/dev/null 2>&1; then
    return 0
  fi
  kubectl debug -h >/dev/null 2>&1
}

# Resolve pod's node arch (kubernetes.io/arch), fallback to host arch on failure.
k_resolve_pod_arch() {
  local ns="$1" pod="$2"
  local node arch
  node="$(kubectl get pod "$pod" ${ns:+-n "$ns"} -o jsonpath='{.spec.nodeName}' 2>/dev/null || true)"
  if [ -n "$node" ]; then
    arch="$(kubectl get node "$node" -o jsonpath='{.metadata.labels.kubernetes\.io/arch}' 2>/dev/null || true)"
  fi
  case "$arch" in
    amd64|arm64) echo "$arch" ;;
    *) detect_arch_host ;;
  esac
}

# Resolve container arch via docker inspect, fallback to host arch.
docker_resolve_container_arch() {
  local target="$1"
  local arch
  arch="$(docker inspect -f '{{.Architecture}}' "$target" 2>/dev/null || true)"
  case "$arch" in
    amd64|x86_64) echo "amd64" ;;
    arm64|aarch64) echo "arm64" ;;
    *) detect_arch_host ;;
  esac
}

_is_elf() {
  # Check ELF magic without extra deps (od is in coreutils)
  [ -s "$1" ] || return 1
  local magic
  magic="$(head -c 4 "$1" 2>/dev/null | od -An -t x1 | tr -d ' \n')"
  [ "$magic" = "7f454c46" ]  # 0x7F 'E' 'L' 'F'
}

_fetch_busybox_to() {
  # args: <dest-path> [arch]
  local dest="$1"
  local arch="${2:-$(detect_arch_host)}"
  local urls
  if [ "$arch" = "arm64" ]; then
    urls="$PODFILES_BUSYBOX_URLS_ARM64"
  else
    urls="$PODFILES_BUSYBOX_URLS_AMD64"
  fi

  for u in $urls; do
    say "$ICON_INFO trying BusyBox from ${u}"
    if curl -fsSL "$u" -o "$dest"; then
      chmod +x "$dest" || true
      if _is_elf "$dest"; then
        ok "$ICON_OK downloaded BusyBox for $arch"
        return 0
      fi
      warn "downloaded file is not ELF; ignoring"
    else
      warn "fetch failed from ${u}"
    fi
  done

  # docker fallback: extract /bin/busybox from busybox:latest
  if command -v docker >/dev/null 2>&1; then
    warn "falling back to extracting BusyBox from docker image…"
    local img="busybox:latest" cid=""
    if docker pull "$img" >/dev/null 2>&1; then
      cid="$(docker create "$img" true 2>/dev/null || true)"
      if [ -n "$cid" ]; then
        if docker cp "$cid:/bin/busybox" "$dest" >/dev/null 2>&1; then
          docker rm -f "$cid" >/dev/null 2>&1 || true
          chmod +x "$dest" || true
          if _is_elf "$dest"; then
            ok "$ICON_OK extracted BusyBox from $img"
            return 0
          fi
        fi
        docker rm -f "$cid" >/dev/null 2>&1 || true
      fi
    fi
  fi

  err "could not obtain a BusyBox binary (all URLs failed, docker fallback unavailable/failed).
Set PODFILES_BUSYBOX_URLS_AMD64/ARM64 to your own mirror and retry."
  return 1
}

###############################################################################
# Kubernetes flows
###############################################################################
k8s_attach() {
  need kubectl
  local ns="" pod="" img="$PODFILES_EPHEMERAL_IMAGE" name=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -n|--namespace) ns="$2"; shift 2;;
      --image) img="$2"; shift 2;;
      --name) name="$2"; shift 2;;
      --) shift; break;;
      *) if [ -z "${pod:-}" ]; then pod="$1"; shift; else break; fi;;
    esac
  done
  local cmd=( "${@:-/bin/bash}" )
  [ -n "$pod" ] || { err "POD required"; return 2; }

  [ -n "$name" ] || name="podfiles-$(date +%H%M%S)-$RANDOM"
  if ! k_can_ephemeral; then
    warn "Ephemeral containers likely not permitted; try: '$SELF k8s copy-busybox [-n ns] $pod'"
  fi

  local target=""
  target="$(kubectl get pod "$pod" ${ns:+-n "$ns"} -o jsonpath='{.spec.containers[0].name}' 2>/dev/null || true)"

  # shellcheck disable=SC2206
  local base=( kubectl debug "pod/$pod" --image="$img" -it --share-processes )
  [ -n "$ns" ] && base+=( -n "$ns" )
  [ -n "$target" ] && base+=( --target="$target" )
  base+=( --container="$name" -- )

  say "$ICON_RUN attach → ${C_DIM}${img}${C_RST}"
  exec "${base[@]}" "${cmd[@]}"
}

k8s_copy_busybox() {
  need kubectl; need curl
  local ns="" pod="" as_list="ping,nslookup,wget,traceroute,sh"
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -n|--namespace) ns="$2"; shift 2;;
      --as) as_list="$2"; shift 2;;
      *) if [ -z "${pod:-}" ]; then pod="$1"; shift; else break; fi;;
    esac
  done
  [ -n "$pod" ] || { err "POD required"; return 2; }

  # pick arch of the node running this pod
  local arch; arch="$(k_resolve_pod_arch "$ns" "$pod")"

  # temp dir always defined (avoid unbound var on set -u)
  local tmp; tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
  local bb="$tmp/busybox"
  if ! _fetch_busybox_to "$bb" "$arch"; then
    return 1
  fi

  kubectl exec ${ns:+-n "$ns"} "$pod" -- sh -lc "mkdir -p '$PODFILES_BIN_DIR' '$PODFILES_TMP_DIR'" >/dev/null
  kubectl cp "$bb" "${ns:+$ns/}$pod:$PODFILES_BIN_DIR/busybox" >/dev/null

  IFS=',' read -r -a tools <<<"$as_list"
  local link_cmd=""
  for t in "${tools[@]}"; do
    t="$(printf '%s' "$t" | xargs)"
    [ -z "$t" ] && continue
    link_cmd="${link_cmd}ln -sf '$PODFILES_BIN_DIR/busybox' '$PODFILES_BIN_DIR/$t' ; "
  done
  link_cmd="${link_cmd}printf 'export PATH=%s:\\\$PATH\\n' '$PODFILES_BIN_DIR' > '$PODFILES_TMP_DIR/profile'"

  kubectl exec ${ns:+-n "$ns"} "$pod" -- sh -lc "$link_cmd" >/dev/null

  ok "$ICON_OK BusyBox installed → $pod:${PODFILES_BIN_DIR} (arch=${arch})"
  cat <<MSG
Use now:
  kubectl exec -it ${ns:+-n "$ns"} "$pod" -- sh -lc 'export PATH=${PODFILES_BIN_DIR}:\$PATH; sh'
MSG
}

k8s_shell() {
  local ns="" pod=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -n|--namespace) ns="$2"; shift 2;;
      *) if [ -z "${pod:-}" ]; then pod="$1"; shift; else break; fi;;
    esac
  done
  [ -n "$pod" ] || { err "POD required"; return 2; }

  if k8s_attach ${ns:+-n "$ns"} "$pod" -- /bin/bash; then
    return 0
  fi
  warn "Ephemeral attach failed → falling back to BusyBox"
  k8s_copy_busybox ${ns:+-n "$ns"} "$pod" --as "ping,nslookup,wget,traceroute,sh"
  exec kubectl exec -it ${ns:+-n "$ns"} "$pod" -- sh -lc "export PATH=$PODFILES_BIN_DIR:\$PATH; sh"
}

###############################################################################
# Docker flows
###############################################################################
docker_netshoot() {
  need docker
  local target="${1:-}"; shift || true
  [ -n "$target" ] || { err "CONTAINER required"; return 2; }
  local cmd=( "${@:-bash}" )
  say "$ICON_RUN netshoot → ${C_DIM}$PODFILES_EPHEMERAL_IMAGE${C_RST} (network=container:${target})"
  exec docker run --rm -it --network "container:${target}" "$PODFILES_EPHEMERAL_IMAGE" "${cmd[@]}"
}

docker_copy_busybox() {
  need docker; need curl
  local target="${1:-}"; shift || true
  [ -n "$target" ] || { err "CONTAINER required"; return 2; }
  local as_list="ping,nslookup,wget,traceroute,sh"
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --as) as_list="$2"; shift 2;;
      *) break;;
    esac
  done

  local arch; arch="$(docker_resolve_container_arch "$target")"

  local tmp; tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
  local bb="$tmp/busybox"
  if ! _fetch_busybox_to "$bb" "$arch"; then
    return 1
  fi

  docker exec "$target" sh -lc "mkdir -p '$PODFILES_BIN_DIR' '$PODFILES_TMP_DIR'" >/dev/null
  docker cp "$bb" "$target:$PODFILES_BIN_DIR/busybox" >/dev/null

  IFS=',' read -r -a tools <<<"$as_list"
  local link_cmd=""
  for t in "${tools[@]}"; do
    t="$(printf '%s' "$t" | xargs)"
    [ -z "$t" ] && continue
    link_cmd="${link_cmd}ln -sf '$PODFILES_BIN_DIR/busybox' '$PODFILES_BIN_DIR/$t' ; "
  done
  link_cmd="${link_cmd}printf 'export PATH=%s:\\\$PATH\\n' '$PODFILES_BIN_DIR' > '$PODFILES_TMP_DIR/profile'"

  docker exec "$target" sh -lc "$link_cmd" >/dev/null
  ok "$ICON_OK BusyBox installed → container:${target} at ${PODFILES_BIN_DIR} (arch=${arch})"
  cat <<'MSG'
Use now:
  docker exec -it <container> sh -lc 'export PATH=/tmp/podfiles/bin:$PATH; sh'
MSG
}

###############################################################################
# Doctor (preflight diagnostics)
###############################################################################
doctor() {
  box "podfiles doctor"
  printf '%s\n' "• Host arch: $(detect_arch_host)"
  printf '%s'   "• kubectl: "
  if command -v kubectl >/dev/null 2>&1; then
    echo "found"
    printf '%s' "  - Ephemeral containers allowed: "
    if k_can_ephemeral; then echo "likely YES"; else echo "likely NO"; fi
  else
    echo "missing"
  fi

  printf '%s' "• docker: "
  if command -v docker >/dev/null 2>&1; then echo "found"; else echo "missing"; fi

  printf '%s' "• curl: "
  if command -v curl   >/dev/null 2>&1; then echo "found"; else echo "missing"; fi

  echo
  echo "Images/Binaries:"
  echo "  - Ephemeral image: $PODFILES_EPHEMERAL_IMAGE"
  echo "  - BusyBox URLs (amd64): $PODFILES_BUSYBOX_URLS_AMD64"
  echo "  - BusyBox URLs (arm64): $PODFILES_BUSYBOX_URLS_ARM64"

  echo
  printf '%s' "• BusyBox fetch probe: "
  local tdir; tdir="$(mktemp -d)"
  if _fetch_busybox_to "$tdir/busybox" >/dev/null 2>&1; then
    echo "ok"
  else
    echo "failed (configure mirrors or ensure docker available for fallback)"
  fi
  rm -rf "$tdir" || true

  echo
  ok "$ICON_OK Doctor complete."
}

###############################################################################
# Main
###############################################################################
main() {
  case "${1:-}" in
    ""|-h|--help) usage; return 0;;
    version) echo "$VERSION"; return 0;;
    doctor) doctor; return 0;;
  esac

  local sub="${1:-}"; shift || true
  case "$sub" in
    k8s)
      local action="${1:-}"; shift || true
      case "$action" in
        attach)        k8s_attach "$@";;
        copy-busybox)  k8s_copy_busybox "$@";;
        shell)         k8s_shell "$@";;
        *) usage; return 2;;
      esac
      ;;
    docker)
      local action="${1:-}"; shift || true
      case "$action" in
        netshoot)      docker_netshoot "$@";;
        copy-busybox)  docker_copy_busybox "$@";;
        *) usage; return 2;;
      esac
      ;;
    *)
      usage; return 2;;
  esac
}

###############################################################################
# Entry (source-safe for tests)
###############################################################################
# If sourced (return succeeds) or explicit request not to run, skip.
if [ "${PODFILES_SOURCE_ONLY:-0}" = "1" ] || ( return 0 2>/dev/null ); then
  :
else
  main "$@"
fi
